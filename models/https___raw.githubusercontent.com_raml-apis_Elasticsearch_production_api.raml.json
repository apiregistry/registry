{"title":"Elasticsearch","baseUri":"{protocol}://{domain}:{port}","baseUriParameters":{"protocol":{"name":"protocol","displayName":"protocol","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"domain":{"name":"domain","displayName":"domain","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"port":{"name":"port","displayName":"port","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"protocols":["{PROTOCOL}"],"mediaType":"application/json","schemas":[{"insertsDocumentReq":"Can not resolve schemas/insertsDocumentReq-schema.json"},{"insertsDocument":"Can not resolve schemas/insertsDocument-schema.json"},{"getDocument":"Can not resolve schemas/getDocument-schema.json"},{"createIndexReq":"Can not resolve schemas/createIndexReq-schema.json"},{"createIndex":"Can not resolve schemas/createIndex-schema.json"},{"deleteDocument":"Can not resolve schemas/deleteDocument-schema.json"},{"updateDocumentReq":"Can not resolve schemas/updateDocumentReq-schema.json"},{"mgetReq":"Can not resolve schemas/mgetReq-schema.json"},{"mgetIndexReq":"Can not resolve schemas/mgetIndexReq-schema.json"},{"mgetIndexTypeReq":"Can not resolve schemas/mgetIndexTypeReq-schema.json"},{"queryReq":"Can not resolve schemas/queryReq-schema.json"},{"query":"Can not resolve schemas/query-schema.json"},{"tasksStatus":"Can not resolve schemas/tasksStatus-schema.json"},{"rerouteSpec":"Can not resolve schemas/rerouteSpec-schema.json"},{"clusterSettings":"Can not resolve schemas/clusterSettings-schema.json"},{"nodeInfoResult":"Can not resolve schemas/nodeInfoResult-schema.json"},{"benchSample":"Can not resolve schemas/benchSample-schema.json"},{"benchResponse":"Can not resolve schemas/benchResponse-schema.json"},{"suggestExample":"Can not resolve schemas/suggestExample-schema.json"},{"suggestResponse":"Can not resolve schemas/suggestResponse-schema.json"},{"searchTemplate":"Can not resolve schemas/searchTemplate-schema.json"},{"searchShardsResponse":"Can not resolve schemas/searchShardsResponse-schema.json"},{"mappingSample":"Can not resolve schemas/mappingSample-schema.json"},{"aliasOps":"Can not resolve schemas/aliasOps-schema.json"},{"aliases":"Can not resolve schemas/aliases-schema.json"},{"indexTemplate":"Can not resolve schemas/indexTemplate-schema.json"},{"termVectorSettings":"Can not resolve schemas/termVectorSettings-schema.json"},{"termVectors":"Can not resolve schemas/termVectors-schema.json"},{"multiTermVectorsRequest":"Can not resolve schemas/multiTermVectorsRequest-schema.json"},{"searchReq":"Can not resolve schemas/searchReq-schema.json"},{"searchResp":"Can not resolve schemas/searchResp-schema.json"},{"mappingFields":"Can not resolve schemas/mappingFields-schema.json"},{"settingsPut":"Can not resolve schemas/settingsPut-schema.json"},{"stats":"Can not resolve schemas/stats-schema.json"},{"warmerPutReq":"Can not resolve schemas/warmerPutReq-schema.json"},{"recovery":"Can not resolve schemas/recovery-schema.json"},{"segments":"Can not resolve schemas/segments-schema.json"},{"countReq":"Can not resolve schemas/countReq-schema.json"},{"count":"Can not resolve schemas/count-schema.json"},{"valid":"Can not resolve schemas/valid-schema.json"},{"explainReq":"Can not resolve schemas/explainReq-schema.json"},{"nodes":"Can not resolve schemas/nodes-schema.json"},{"percolateCountResponse":"Can not resolve schemas/percolateCountResponse-schema.json"},{"suggestBody":"Can not resolve schemas/suggestBody-schema.json"},{"benchAbortResponse":"Can not resolve schemas/benchAbortResponse-schema.json"}],"traits":[{"canDeleteSelected":{"name":"canDeleteSelected"}},{"creatingDocument":{"name":"creatingDocument"}}],"resourceTypes":[{"msearchType":{"name":"msearchType"}},{"recoveryType":{"name":"recoveryType"}},{"catResource":{"name":"catResource"}},{"flushType":{"name":"flushType"}},{"bulkType":{"name":"bulkType"}},{"cacheClearType":{"name":"cacheClearType"}},{"searchType":{"name":"searchType"}},{"refreshType":{"name":"refreshType"}},{"optimizeType":{"name":"optimizeType"}},{"mgetType":{"name":"mgetType"}},{"analizerType":{"name":"analizerType"}},{"base":{"name":"base"}},{"segmentsType":{"name":"segmentsType"}},{"multiTermVectors":{"name":"multiTermVectors"}},{"mappingType":{"name":"mappingType"}},{"validateType":{"name":"validateType"}},{"indexSettingsType":{"name":"indexSettingsType"}},{"warmerType":{"name":"warmerType"}},{"countType":{"name":"countType"}},{"mpercolateType":{"name":"mpercolateType"}}],"resources":[{"relativeUri":"/{_index}","type":"base","uriParameters":{"_index":{"name":"_index","displayName":"_index","type":"string","required":true,"repeat":false,"description":"Most APIs that refer to an index parameter support execution across multiple indices, using simple test1,test2,test3 notation (or _all for all indices). \nIt also support wildcards, for example: test*, \nand the ability to \"add\" (+) and \"remove\" (-), for example: +test*,-test3.\n","__METADATA__":{"primitiveValuesMeta":{"type":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"createIndex","example":"Can not resolve examples/createIndex-example.json","schemaContent":"Can not resolve schemas/createIndex-schema.json"}}}},"body":{"application/json":{"name":"application/json","schema":"createIndexReq","example":"Can not resolve examples/createIndexReq-example.json","schemaContent":"Can not resolve schemas/createIndexReq-schema.json"}},"protocols":["{PROTOCOL}"],"description":"The index operation automatically creates an index if it has not been created before (check out the create index API for manually creating an index), and also automatically creates a dynamic type mapping for the specific type if one has not yet been created (check out the put mapping API for manually creating a type mapping).","method":"post","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"createIndex","example":"Can not resolve examples/createIndex-example.json","schemaContent":"Can not resolve schemas/createIndex-schema.json"}}}},"body":{"application/json":{"name":"application/json","schema":"createIndexReq","example":"Can not resolve examples/createIndexReq-example.json","schemaContent":"Can not resolve schemas/createIndexReq-schema.json"}},"protocols":["{PROTOCOL}"],"description":"The create index API allows to instantiate an index. Elasticsearch provides support for multiple indices, including executing operations across several indices.","method":"put","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"protocols":["{PROTOCOL}"],"description":"The delete index API allows to delete an existing index.","method":"delete","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"responses":{"200":{"code":"200"},"404":{"code":"404"}},"protocols":["{PROTOCOL}"],"description":"Used to check if the index (indices) exists or not. For example:\ncurl -XHEAD 'http://localhost:9200/twitter'\n\nThe HTTP status code indicates if the index exists or not. A 404 means it does not exist, and \n200 \nmeans it does.\n","method":"head","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"resources":[{"relativeUri":"/{_type}","type":"base","uriParameters":{"_type":{"name":"_type","displayName":"_type","type":"string","required":true,"repeat":false,"description":"All search APIs can be applied across multiple types within an index, and across multiple indices with support for the multi index syntax.\nWe can also search within specific types: /http://localhost:9200/twitter/tweet,user/_search?q=user:kimchy'\nSet it to _all in order to fetch the first document matching the id across all types.\n","__METADATA__":{"primitiveValuesMeta":{"type":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"responses":{"201":{"code":"201","body":{"application/json":{"name":"application/json"}}}},"body":{"application/json":{"name":"application/json","schema":"insertsDocumentReq","example":"Can not resolve examples/insertsDocumentReq-example.json","schemaContent":"Can not resolve schemas/insertsDocumentReq-schema.json"}},"protocols":["{PROTOCOL}"],"description":"The index operation can be executed without specifying the id. In such a case, an id will be generated automatically. In addition, the op_type will automatically be set to create. Here is an example (note the POST used instead of PUT)","method":"post","is":["creatingDocument"],"__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"body":{"application/json":{"name":"application/json","schema":"mgetIndexTypeReq","example":"Can not resolve examples/mgetIndexTypeReq-example.json","schemaContent":"Can not resolve schemas/mgetIndexTypeReq-schema.json"}},"protocols":["{PROTOCOL}"],"description":"Get all documents of the type.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"responses":{"200":{"code":"200"},"400":{"code":"400"}},"protocols":["{PROTOCOL}"],"description":"Used to check if a type/types exists in an index/indices.The HTTP status code indicates if the type exists or not. A 404 means it does not exist, and  200  means it does.","method":"head","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"protocols":["{PROTOCOL}"],"description":"Allow to delete a mapping (type) along with its data","method":"delete","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"resources":[{"relativeUri":"/{id}","type":"base","uriParameters":{"id":{"name":"id","displayName":"id","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"body":{"application/json":{"name":"application/json","example":"Can not resolve examples/insertsDocumentReq-example.json"}},"protocols":["{PROTOCOL}"],"queryParameters":{"op_type":{"name":"op_type","displayName":"op_type","type":"string","required":false,"example":"create","repeat":false,"description":"The index operation also accepts an op_type that can be used to force a create operation, allowing for \"put-if-absent\" behavior. When create is used, the index operation will fail if a document by that id already exists in the index.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"description":"The index API adds or updates a typed JSON document in a specific index, making it searchable.","method":"put","is":["creatingDocument"],"__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"getDocument","example":"Can not resolve examples/getDocument-example.json","schemaContent":"Can not resolve schemas/getDocument-schema.json"}}}},"protocols":["{PROTOCOL}"],"queryParameters":{"realtime":{"name":"realtime","displayName":"realtime","type":"boolean","required":false,"repeat":false,"description":"In order to disable realtime GET, one can either set realtime parameter to false, or globally default it to by setting the action.get.realtime to false in the node configuration.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"fields":{"name":"fields","displayName":"fields","type":"string","required":false,"example":"title,content","repeat":false,"description":"When getting a document, one can specify fields to fetch from it. They will, when possible, be fetched as stored fields (fields mapped as stored in the mapping).","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"_source":{"name":"_source","displayName":"_source","type":"string","required":false,"example":"*.id,retweeted","repeat":false,"description":"By default, the get operation returns the contents of the _source field unless you have used the fields parameter or if the _source field is disabled. You can turn off _source retrieval by using the _source parameter","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"_source_include":{"name":"_source_include","displayName":"_source_include","type":"string","required":false,"example":"*.id&_source_exclude=entities","repeat":false,"description":"If you only need one or two fields from the complete _source, you can use the _source_include & _source_exclude parameters to include or filter out that parts you need. This can be especially helpful with large documents where partial retrieval can save on network overhead. Both parameters take a comma separated list of fields or wildcard expressions","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"_source_exclude":{"name":"_source_exclude","displayName":"_source_exclude","type":"string","required":false,"example":"*.id&_source_exclude=entities","repeat":false,"description":"If you only need one or two fields from the complete _source, you can use the _source_include & _source_exclude parameters to include or filter out that parts you need. This can be especially helpful with large documents where partial retrieval can save on network overhead. Both parameters take a comma separated list of fields or wildcard expressions.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"routing":{"name":"routing","displayName":"routing","type":"string","required":false,"example":"kimchy","repeat":false,"description":"When indexing using the ability to control the routing, in order to get a document, the routing value should also be provided.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"preference":{"name":"preference","displayName":"preference","type":"string","required":false,"repeat":false,"description":"Controls a preference of which shard replicas to execute the get request on. By default, the operation is randomized between the shard replicas. A custom value will be used to guarantee that the same shards will be used for the same custom value. This can help with \"jumping values\" when hitting different shards in different refresh states. A sample value can be something like the web session id, or the user name.","enum":["_primary","_local"],"__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"version":{"name":"version","displayName":"version","type":"string","required":false,"example":"111","repeat":false,"description":"You can use the version parameter to retrieve the document only if its current version is equal to the specified one.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"version_type":{"name":"version_type","displayName":"version_type","type":"string","required":false,"repeat":false,"description":"This behavior is the same for all version types with the exception of version type FORCE which always retrieves the document.","enum":["FORCE"],"__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"description":"The get API allows to get a typed JSON document from the index based on its id.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"responses":{"200":{"code":"200"}},"protocols":["{PROTOCOL}"],"description":"The API also allows to check for the existence of a document using HEAD.","method":"head","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"deleteDocument","example":"Can not resolve examples/deleteDocument-example.json","schemaContent":"Can not resolve schemas/deleteDocument-schema.json"}}}},"protocols":["{PROTOCOL}"],"queryParameters":{"version":{"name":"version","displayName":"version","type":"string","required":false,"repeat":false,"description":"Each document indexed is versioned. When deleting a document, the version can be specified to make sure the relevant document we are trying to delete is actually being deleted and it has not changed in the meantime. Every write operation executed on a document, deletes included, causes its version to be incremented.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"parent":{"name":"parent","displayName":"parent","type":"string","required":false,"repeat":false,"description":"The parent parameter can be set, which will basically be the same as setting the routing parameter. Note that deleting a parent document does not automatically delete its children. One way of deleting all child documents given a parent id is to perform a delete by query on the child index with the automatically generated (and indexed) field _parent, which is in the format parent_type#parent_id.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"replication":{"name":"replication","displayName":"replication","type":"string","required":false,"repeat":false,"description":"he replication of the operation can be done in an asynchronous manner to the replicas (the operation will return once it has be executed on the primary shard). The replication parameter can be set to async (defaults to sync) in order to enable it.","enum":["async"],"__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"consistency":{"name":"consistency","displayName":"consistency","type":"string","required":false,"repeat":false,"description":"Control if the operation will be allowed to execute based on the number of active shards within that partition (replication group). The values allowed are one, quorum, and all. The parameter to set it is consistency, and it defaults to the node level setting of action.write_consistency which in turn defaults to quorum.","enum":["quorum","one","all"],"__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"refresh":{"name":"refresh","displayName":"refresh","type":"boolean","required":false,"repeat":false,"description":"The refresh parameter can be set to true in order to refresh the relevant shard after the delete operation has occurred and make it searchable. Setting it to true should be done after careful thought and verification that this does not cause a heavy load on the system (and slows down indexing).","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"timeout":{"name":"timeout","displayName":"timeout","type":"string","required":false,"example":"5m","repeat":false,"description":"The primary shard assigned to perform the delete operation might not be available when the delete operation is executed. Some reasons for this might be that the primary shard is currently recovering from a gateway or undergoing relocation. By default, the delete operation will wait on the primary shard to become available for up to 1 minute before failing and responding with an error. The timeout parameter can be used to explicitly specify how long it waits.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"description":"The delete API allows to delete a typed JSON document from a specific index based on its id.","method":"delete","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"resources":[{"relativeUri":"/_create","type":"base","methods":[{"protocols":["{PROTOCOL}"],"description":"Here is an example of using option to specify create.","method":"put","is":["creatingDocument"],"__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_create","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_create"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/{id}/_create"},{"relativeUri":"/_source","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"description":"Use the endpoint to get just the _source field of the document, without any additional content around it.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"responses":{"200":{"code":"200"}},"protocols":["{PROTOCOL}"],"description":"Note, there is also a HEAD variant for the _source endpoint to efficiently test for document existence.","method":"head","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_source","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_source"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/{id}/_source"},{"relativeUri":"/_update","type":"base","methods":[{"body":{"application/json":{"name":"application/json","schema":"updateDocumentReq","example":"Can not resolve examples/updateDocumentReq-example.json","schemaContent":"Can not resolve schemas/updateDocumentReq-schema.json"}},"protocols":["{PROTOCOL}"],"queryParameters":{"version":{"name":"version","displayName":"version","type":"string","required":false,"example":"version=2","repeat":false,"description":"Each indexed document is given a version number. The associated version number is returned as part of the response to the index API request. The index API optionally allows for optimistic concurrency control when the version parameter is specified. This will control the version of the document the operation is intended to be executed against. A good example of a use case for versioning is performing a transactional read-then-update. Specifying a version from the document initially read ensures no changes have happened in the meantime (when reading in order to update, it is recommended to set preference to _primary).","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"version_type":{"name":"version_type","displayName":"version_type","type":"string","required":false,"repeat":false,"description":"Next to the internal & external version types explained above, Elasticsearch also supports other types for specific use cases. Here is an overview of the different version types and their semantics.","enum":["external_gt","external","force","internal","external_gte"],"__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"routing":{"name":"routing","displayName":"routing","type":"string","required":false,"example":"kimchy","repeat":false,"description":"By default, shard placement  id value. For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the routing parameter.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"parent":{"name":"parent","displayName":"parent","type":"string","required":false,"example":"1111","repeat":false,"description":"A child document can be indexed by specifying its parent when indexing","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"consistency":{"name":"consistency","displayName":"consistency","type":"string","required":false,"repeat":false,"description":"To prevent writes from taking place on the \"wrong\" side of a network partition, by default, index operations only succeed if a quorum (>replicas/2+1) of active shards are available. This default can be overridden on a node-by-node basis using the action.write_consistency setting. To alter this behavior per-operation, the consistency request parameter can be used.","enum":["quorum","one","all"],"__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"replication":{"name":"replication","displayName":"replication","type":"string","required":false,"repeat":false,"description":"By default, the index operation only returns after all shards within the replication group have indexed the document (sync replication). To enable asynchronous replication, causing the replication process to take place in the background, set the replication parameter to async. When asynchronous replication is used, the index operation will return as soon as the operation succeeds on the primary shard.","enum":["async"],"__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"refresh":{"name":"refresh","displayName":"refresh","type":"boolean","required":false,"repeat":false,"description":"To refresh the index immediately after the operation occurs, so that the document appears in search results immediately, the refresh parameter can be set to true. Setting this option to true should ONLY be done after careful thought and verification that it does not lead to poor performance, both from an indexing and a search standpoint. Note, getting a document using the get API is completely realtime.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"timeout":{"name":"timeout","displayName":"timeout","type":"string","required":false,"example":"5m","repeat":false,"description":"The primary shard assigned to perform the index operation might not be available when the index operation is executed. Some reasons for this might be that the primary shard is currently recovering from a gateway or undergoing relocation. By default, the index operation will wait on the primary shard to become available for up to 1 minute before failing and responding with an error. The timeout parameter can be used to explicitly specify how long it waits.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"fields":{"name":"fields","displayName":"fields","type":"string","required":false,"example":"title,content","repeat":false,"description":"When getting a document, one can specify fields to fetch from it. They will, when possible, be fetched as stored fields (fields mapped as stored in the mapping).","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"retry_on_conflict":{"name":"retry_on_conflict","displayName":"retry_on_conflict","type":"string","required":false,"default":0,"repeat":false,"description":"support retry_on_conflict which controls how many times to retry if there is a version conflict between getting the document and indexing / deleting it.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"description":"The update API allows to update a document based on a script provided. The operation gets the document (collocated with the shard) from the index, runs the script (with optional script language and parameters), and index back the result (also allows to delete, or ignore the operation). It uses versioning to make sure no updates have happened during the \"get\" and \"reindex\".","method":"post","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_update","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_update"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/{id}/_update"},{"relativeUri":"/_mlt","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"queryParameters":{"mlt_fields":{"name":"mlt_fields","displayName":"mlt_fields","type":"string","required":false,"repeat":false,"description":"fields of the document will be used in the more_like_this query generated.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"min_doc_freq":{"name":"min_doc_freq","displayName":"min_doc_freq","type":"number","required":false,"repeat":false,"__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"include":{"name":"include","displayName":"include","type":"boolean","required":false,"default":false,"repeat":false,"__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"description":"The more like this (mlt) API allows to get documents that are \"like\" a specified document.\n","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_mlt","description":"The API simply results in executing a search request with moreLikeThis query (http parameters match the parameters to the more_like_this query). This means that the body of the request can \noptionally include all the request body options in the search API (aggs, from/to and so on). Internally, the more like this API is equivalent to performing a boolean query of more_like_this_field queries, with one query per specified \nmlt_fields.\n\nRest parameters relating to search are also allowed, including search_type, \nsearch_indices, \nsearch_types, \nsearch_scroll, \nsearch_size and \nsearch_from.\n\nWhen no mlt_fields are specified, all the fields of the document will be used in the \nmore_like_this query generated.\n\nBy default, the queried document is excluded from the response (include set to false).\n\nNote: In order to use the mlt feature a \nmlt_field needs to be either be \nstored, store \nterm_vector or \nsource needs to be enabled.\n","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_mlt"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/{id}/_mlt"},{"relativeUri":"/_percolate","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"description":"Percolating an existing document","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_percolate","description":"","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_percolate"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/{id}/_percolate"},{"relativeUri":"/_explain","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"body":{"application/json":{"name":"application/json","schema":"explainReq","example":"Can not resolve examples/explainReq-example.json","schemaContent":"Can not resolve schemas/explainReq-schema.json"}},"protocols":["{PROTOCOL}"],"description":"The explain api computes a score explanation for a query and a specific document. This can give useful feedback whether a document matches or didn't match a specific query.\nThe index and type parameters expect a single index and a single type respectively.\n","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_explain","description":"","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_explain"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/{id}/_explain"},{"relativeUri":"/_termvector","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"termVectors","example":"Can not resolve examples/termVectors-example.json","schemaContent":"Can not resolve schemas/termVectors-schema.json"}}}},"body":{"application/json":{"name":"application/json","schema":"termVectorSettings","example":"Can not resolve examples/termVectorSettings-example.json","schemaContent":"Can not resolve schemas/termVectorSettings-schema.json"}},"protocols":["{PROTOCOL}"],"queryParameters":{"fields":{"name":"fields","displayName":"fields","type":"string","required":false,"repeat":false,"description":"Optionally, you can specify the fields for which the information is retrieved either with a parameter in the url","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"description":"Returns information and statistics on terms in the fields of a particular document as stored in the index.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_termvector","description":"","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_termvector"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/{id}/_termvector"}],"displayName":"/{id}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["{id}"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/{id}"},{"relativeUri":"/_bulk","type":"bulkType","methods":[{"protocols":["{PROTOCOL}"],"description":"The bulk API makes it possible to perform many index/delete operations in a single API call. This can greatly increase the indexing speed.","method":"post","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_bulk","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_bulk"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_bulk"},{"relativeUri":"/_query","type":"base","methods":[{"protocols":["{PROTOCOL}"],"description":"The delete by query API allows to delete documents from one or more indices and one or more types based on a query. The query can either be provided using a simple query string as a parameter, or using the Query DSL defined within the request body.","method":"delete","is":["canDeleteSelected"],"__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_query","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_query"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_query"},{"relativeUri":"/_search","type":"searchType","methods":[{"protocols":["{PROTOCOL}"],"description":"Search documents","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_search","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_search"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_search"},{"relativeUri":"/_count","type":"countType","displayName":"/_count","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_count"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_count"},{"relativeUri":"/_mapping","type":"mappingType","methods":[{"body":{"application/json":{"name":"application/json","schema":"mappingSample","example":"Can not resolve examples/mappingSample-example.json","schemaContent":"Can not resolve schemas/mappingSample-schema.json"}},"protocols":["{PROTOCOL}"],"description":"The put mapping API allows to register specific mapping definition for a specific type.","method":"put","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"protocols":["{PROTOCOL}"],"description":"Allow to delete a mapping (type) along with its data","method":"delete","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"resources":[{"relativeUri":"/field/{fields}","type":"mappingType","uriParameters":{"fields":{"name":"fields","displayName":"fields","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"mappingFields","example":"Can not resolve examples/mappingFields-example.json","schemaContent":"Can not resolve schemas/mappingFields-schema.json"}}}},"protocols":["{PROTOCOL}"],"queryParameters":{"include_defaults":{"name":"include_defaults","displayName":"include_defaults","type":"boolean","required":false,"example":"true","repeat":false,"description":"adding include_defaults=true to the query string will cause the response to include default values, which are normally suppressed.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/field/{fields}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["field","{fields}"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_mapping/field/{fields}"}],"displayName":"/_mapping","description":"","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_mapping"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_mapping"},{"relativeUri":"/_warmer/{warmer}","type":"warmerType","uriParameters":{"warmer":{"name":"warmer","displayName":"warmer","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"protocols":["{PROTOCOL}"],"method":"put","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"protocols":["{PROTOCOL}"],"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_warmer/{warmer}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_warmer","{warmer}"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_warmer/{warmer}"},{"relativeUri":"/_warmers/{warmer}","type":"warmerType","uriParameters":{"warmer":{"name":"warmer","displayName":"warmer","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"displayName":"/_warmers/{warmer}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_warmers","{warmer}"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_warmers/{warmer}"},{"relativeUri":"/_mtermvectors","type":"multiTermVectors","displayName":"/_mtermvectors","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_mtermvectors"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_mtermvectors"},{"relativeUri":"/_mget","type":"mgetType","displayName":"/_mget","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_mget"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_mget"},{"relativeUri":"/_validate/query","type":"validateType","displayName":"/_validate/query","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_validate","query"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_validate/query"},{"relativeUri":"/_percolate","type":"base","methods":[{"responses":{"200":{"code":"200"}},"body":{"application/json":{"name":"application/json"}},"protocols":["{PROTOCOL}"],"description":"Traditionally you design documents based on your data and store them into an index and then define queries via the search api in order to retrieve these documents. The percolator works in the opposite direction, first you store queries into an index and then via the percolate api you define documents in order to retrieve these queries.\n\nThe reason that queries can be stored comes from the fact that in Elasticsearch both documents and queries are defined in JSON. This allows you to embed queries into documents via the index api. Elasticsearch can extract the query from a document and make it available to the percolate api. Since documents are also defined as json, you can define a document in a request to the percolate api.\n\nThe percolator and most of its features work in realtime, so once a percolate query is indexed it can immediately be used in the percolate api.\n","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"resources":[{"relativeUri":"/count","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"percolateCountResponse","example":"Can not resolve examples/percolateCountResponse-example.json","schemaContent":"Can not resolve schemas/percolateCountResponse-schema.json"}}}},"protocols":["{PROTOCOL}"],"description":"The count percolate api, only keeps track of the number of matches and doesn't keep track of the actual matches.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/count","description":"The count percolate api, only keeps track of the number of matches and doesn't keep track of actual matches","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["count"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_percolate/count"}],"displayName":"/_percolate","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_percolate"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_percolate"},{"relativeUri":"/_mpercolate","type":"mpercolateType","displayName":"/_mpercolate","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_mpercolate"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_mpercolate"},{"relativeUri":"/_msearch","type":"msearchType","displayName":"/_msearch","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_msearch"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}/_msearch"}],"displayName":"/{_type}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["{_type}"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/{_type}"},{"relativeUri":"/_bulk","type":"bulkType","methods":[{"protocols":["{PROTOCOL}"],"description":"The bulk API makes it possible to perform many index/delete operations in a single API call. This can greatly increase the indexing speed.","method":"post","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_bulk","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_bulk"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_bulk"},{"relativeUri":"/_query","type":"base","methods":[{"protocols":["{PROTOCOL}"],"description":"The delete by query API allows to delete documents from one or more indices and one or more types based on a query. The query can either be provided using a simple query string as a parameter, or using the Query DSL defined within the request body.","method":"delete","is":["canDeleteSelected"],"__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_query","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_query"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_query"},{"relativeUri":"/.percolator","type":"base","methods":[{"body":{"application/json":{"name":"application/json"}},"protocols":["{PROTOCOL}"],"description":"Adding a query to the percolator.","method":"put","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"description":"returns percolator","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"responses":{"200":{"code":"200"}},"protocols":["{PROTOCOL}"],"description":"In order to un-register a percolate query the delete api can be used. So if the previous added query needs to be deleted the following delete requests needs to be executed","method":"delete","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/.percolator","description":"Traditionally you design documents based on your data and store them into an index and then define queries via the search api in order to retrieve these documents. The percolator works in the opposite direction, first you store queries into an index and then via the percolate api you define documents in order to retrieve these queries.\n\nThe reason that queries can be stored comes from the fact that in Elasticsearch both documents and queries are defined in JSON. This allows you to embed queries into documents via the index api. Elasticsearch can extract the query from a document and make it available to the percolate api. Since documents are also defined as json, you can define a document in a request to the percolate api.\n\nThe percolator and most of its features work in realtime, so once a percolate query is indexed it can immediately be used in the percolate api.\n","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":[".percolator"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/.percolator"},{"relativeUri":"/_search_shards","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"searchShardsResponse","example":"Can not resolve examples/searchShardsResponse-example.json","schemaContent":"Can not resolve schemas/searchShardsResponse-schema.json"}},"description":""}},"protocols":["{PROTOCOL}"],"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_search_shards","description":"The search shards api returns the indices and shards that a search request would be executed against. This can give useful feedback for working out issues or planning optimizations with routing and shard preferences","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_search_shards"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_search_shards"},{"relativeUri":"/_search","type":"searchType","displayName":"/_search","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_search"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_search"},{"relativeUri":"/_count","type":"countType","displayName":"/_count","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_count"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_count"},{"relativeUri":"/_open","type":"base","methods":[{"protocols":["{PROTOCOL}"],"method":"post","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_open","description":"The open and close index APIs allow to close an index, and later on opening it. A closed index has almost no overhead on the cluster (except for maintaining its metadata), and is blocked for read/write operations. A closed index can be opened which will then go through the normal recovery process.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_open"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_open"},{"relativeUri":"/_close","type":"base","methods":[{"protocols":["{PROTOCOL}"],"method":"post","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_close","description":"The open and close index APIs allow to close an index, and later on opening it. A closed index has almost no overhead on the cluster (except for maintaining its metadata), and is blocked for read/write operations. A closed index can be opened which will then go through the normal recovery process.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_close"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_close"},{"relativeUri":"/_mapping","type":"mappingType","methods":[{"protocols":["{PROTOCOL}"],"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"resources":[{"relativeUri":"/{types}","type":"mappingType","uriParameters":{"types":{"name":"types","displayName":"types","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"protocols":["{PROTOCOL}"],"description":"Allow to delete a mapping (type) along with its data.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"protocols":["{PROTOCOL}"],"method":"delete","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"protocols":["{PROTOCOL}"],"method":"put","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"resources":[{"relativeUri":"/{fields}","type":"mappingType","uriParameters":{"fields":{"name":"fields","displayName":"fields","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"protocols":["{PROTOCOL}"],"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/{fields}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["{fields}"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_mapping/{types}/{fields}"}],"displayName":"/{types}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["{types}"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_mapping/{types}"}],"displayName":"/_mapping","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_mapping"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_mapping"},{"relativeUri":"/_alias/{aliasName}","type":"base","uriParameters":{"aliasName":{"name":"aliasName","displayName":"aliasName","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"aliases","example":"Can not resolve examples/aliases-example.json","schemaContent":"Can not resolve schemas/aliases-schema.json"}}}},"protocols":["{PROTOCOL}"],"description":"The get index alias api allows to filter by alias name and index name. This api redirects to the master and fetches the requested index aliases, if available. This api only serialises the found index aliases.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"protocols":["{PROTOCOL}"],"queryParameters":{"routing":{"name":"routing","displayName":"routing","type":"string","required":false,"repeat":false,"description":"An optional routing that can be associated with an alias.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"filter":{"name":"filter","displayName":"filter","type":"string","required":false,"repeat":false,"description":"An optional filter that can be associated with an alias.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"description":"An alias can also be added to index with this endpoint","method":"put","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"protocols":["{PROTOCOL}"],"description":"deletes alias with a given name","method":"delete","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_alias/{aliasName}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_alias","{aliasName}"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_alias/{aliasName}"},{"relativeUri":"/_settings","type":"indexSettingsType","displayName":"/_settings","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_settings"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_settings"},{"relativeUri":"/_analyze","type":"analizerType","displayName":"/_analyze","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_analyze"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_analyze"},{"relativeUri":"/_warmer/{warmerName}","type":"warmerType","uriParameters":{"warmerName":{"name":"warmerName","displayName":"warmerName","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"protocols":["{PROTOCOL}"],"method":"put","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"protocols":["{PROTOCOL}"],"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_warmer/{warmerName}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_warmer","{warmerName}"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_warmer/{warmerName}"},{"relativeUri":"/_warmers/{warmerName}","type":"warmerType","uriParameters":{"warmerName":{"name":"warmerName","displayName":"warmerName","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"protocols":["{PROTOCOL}"],"method":"put","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"protocols":["{PROTOCOL}"],"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_warmers/{warmerName}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_warmers","{warmerName}"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_warmers/{warmerName}"},{"relativeUri":"/_status","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_status","description":"The indices status API allows to get a comprehensive status information of one or more indices.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_status"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_status"},{"relativeUri":"/_stats","type":"base","methods":[{"protocols":["{PROTOCOL}"],"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"resources":[{"relativeUri":"/{statSpec}","uriParameters":{"statSpec":{"name":"statSpec","displayName":"statSpec","type":"string","required":true,"repeat":false,"enum":["warmer","flush","get","store","search","docs","indexing","merge","fielddata","suggest","completion","refresh"],"__METADATA__":{"primitiveValuesMeta":{"type":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/{statSpec}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["{statSpec}"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_stats/{statSpec}"}],"displayName":"/_stats","description":"Indices level stats provide statistics on different operations happening on an index. The API provides statistics on the index level scope (though most stats can also be retrieved using node level scope).","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_stats"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_stats"},{"relativeUri":"/_segments","type":"segmentsType","displayName":"/_segments","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_segments"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_segments"},{"relativeUri":"/_recovery","type":"recoveryType","displayName":"/_recovery","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_recovery"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_recovery"},{"relativeUri":"/_cache/clear","type":"cacheClearType","displayName":"/_cache/clear","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_cache","clear"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_cache/clear"},{"relativeUri":"/_flush","type":"flushType","displayName":"/_flush","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_flush"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_flush"},{"relativeUri":"/_refresh","type":"refreshType","displayName":"/_refresh","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_refresh"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_refresh"},{"relativeUri":"/_optimize","type":"optimizeType","displayName":"/_optimize","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_optimize"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_optimize"},{"relativeUri":"/_mtermvectors","type":"multiTermVectors","displayName":"/_mtermvectors","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_mtermvectors"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_mtermvectors"},{"relativeUri":"/_mget","type":"mgetType","displayName":"/_mget","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_mget"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_mget"},{"relativeUri":"/_validate/query","type":"validateType","displayName":"/_validate/query","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_validate","query"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_validate/query"},{"relativeUri":"/_mpercolate","type":"mpercolateType","displayName":"/_mpercolate","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_mpercolate"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_mpercolate"},{"relativeUri":"/_msearch","type":"msearchType","displayName":"/_msearch","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_msearch"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}/_msearch"}],"displayName":"/{_index}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["{_index}"],"absoluteUri":"{protocol}://{domain}:{port}/{_index}"},{"relativeUri":"/_mget","type":"mgetType","displayName":"/_mget","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_mget"],"absoluteUri":"{protocol}://{domain}:{port}/_mget"},{"relativeUri":"/_bulk","type":"bulkType","methods":[{"protocols":["{PROTOCOL}"],"method":"post","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_bulk","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_bulk"],"absoluteUri":"{protocol}://{domain}:{port}/_bulk"},{"relativeUri":"/_nodes","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"nodes","example":"Can not resolve examples/nodes-example.json","schemaContent":"Can not resolve schemas/nodes-schema.json"}}}},"protocols":["{PROTOCOL}"],"description":"The cluster nodes info API allows to retrieve one or more (or all) of the cluster nodes information.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"resources":[{"relativeUri":"/{nodesIds}/hot_threads","type":"base","uriParameters":{"nodesIds":{"name":"nodesIds","displayName":"nodesIds","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"responses":{"200":{"code":"200","body":{"text/plain":{"name":"text/plain"}}}},"protocols":["{PROTOCOL}"],"queryParameters":{"threads":{"name":"threads","displayName":"threads","type":"number","required":false,"repeat":false,"description":"number of hot threads to provide, defaults to 3.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"interval":{"name":"interval","displayName":"interval","type":"string","required":false,"repeat":false,"description":"the interval to do the second sampling of threads. Defaults to 500ms","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"type":{"name":"type","displayName":"type","type":"string","required":false,"repeat":false,"description":"The type to sample, defaults to cpu, but supports wait and block to see hot threads that are in wait or block state.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/{nodesIds}/hot_threads","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["{nodesIds}","hot_threads"],"absoluteUri":"{protocol}://{domain}:{port}/_nodes/{nodesIds}/hot_threads"},{"relativeUri":"/stats","type":"base","methods":[{"protocols":["{PROTOCOL}"],"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/stats","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["stats"],"absoluteUri":"{protocol}://{domain}:{port}/_nodes/stats"},{"relativeUri":"/hot_threads","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"text/plain":{"name":"text/plain"}}}},"protocols":["{PROTOCOL}"],"queryParameters":{"threads":{"name":"threads","displayName":"threads","type":"number","required":false,"repeat":false,"description":"number of hot threads to provide, defaults to 3.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"interval":{"name":"interval","displayName":"interval","type":"string","required":false,"repeat":false,"description":"the interval to do the second sampling of threads. Defaults to 500ms.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"type":{"name":"type","displayName":"type","type":"string","required":false,"repeat":false,"description":"The type to sample, defaults to cpu, but supports wait and block to see hot threads that are in wait or block state.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/hot_threads","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["hot_threads"],"absoluteUri":"{protocol}://{domain}:{port}/_nodes/hot_threads"},{"relativeUri":"/{nodeIds}/stats{statSpec}","type":"base","uriParameters":{"nodeIds":{"name":"nodeIds","displayName":"nodeIds","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"statSpec":{"name":"statSpec","displayName":"statSpec","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"protocols":["{PROTOCOL}"],"queryParameters":{"fields":{"name":"fields","displayName":"fields","type":"string","required":false,"repeat":false,"description":"You can get information about field data memory usage on node level or on index level.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"description":"By default, all stats are returned. You can limit this by combining any of indices, \nos, \nprocess, \njvm, \nnetwork, \ntransport, \nhttp, \nfs, \nbreaker and \nthread_pool. For example:\nindices   \n Indices stats about size, document count, indexing and deletion times, search times, field cache size , merges and flushes \n\nfs   \n File system information, data path, free disk space, read/write stats \n\nhttp   \n HTTP connection information \n\njvm   \n JVM stats, memory pool information, garbage collection, buffer pools \n\nnetwork   \n TCP information \n\nos   \n Operating system stats, load average, cpu, mem, swap \n\nprocess   \n Process statistics, memory consumption, cpu usage, open file descriptors \n\nthread_pool   \n Statistics about each thread pool, including current size, queue and rejected tasks \n\ntransport   \n Transport statistics about sent and received bytes in cluster communication \n\nbreaker   \n Statistics about the field data circuit breaker\n","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/{nodeIds}/stats{statSpec}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["{nodeIds}","stats{statSpec}"],"absoluteUri":"{protocol}://{domain}:{port}/_nodes/{nodeIds}/stats{statSpec}"},{"relativeUri":"/{nodeInfoSpec}","type":"base","uriParameters":{"nodeInfoSpec":{"name":"nodeInfoSpec","displayName":"nodeInfoSpec","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"nodeInfoResult","example":"Can not resolve examples/nodeInfoResult-example.json","schemaContent":"Can not resolve schemas/nodeInfoResult-schema.json"}},"description":""}},"protocols":["{PROTOCOL}"],"description":"The cluster nodes info API allows to retrieve one or more (or all) of the cluster nodes information.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/{nodeInfoSpec}","description":"","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["{nodeInfoSpec}"],"absoluteUri":"{protocol}://{domain}:{port}/_nodes/{nodeInfoSpec}"}],"displayName":"/_nodes","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_nodes"],"absoluteUri":"{protocol}://{domain}:{port}/_nodes"},{"relativeUri":"/_cluster","resources":[{"relativeUri":"/pending_tasks","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"tasksStatus","example":"Can not resolve examples/tasksStatus-example.json","schemaContent":"Can not resolve schemas/tasksStatus-schema.json"}}}},"protocols":["{PROTOCOL}"],"description":"The pending cluster tasks API returns a list of any cluster-level changes (e.g. create index, update mapping, allocate or fail shard) which have not yet been executed.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/pending_tasks","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["pending_tasks"],"absoluteUri":"{protocol}://{domain}:{port}/_cluster/pending_tasks"},{"relativeUri":"/stats","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"stats","example":"Can not resolve examples/stats-example.json","schemaContent":"Can not resolve schemas/stats-schema.json"}}}},"protocols":["{PROTOCOL}"],"description":"The Cluster Stats API allows to retrieve statistics from a cluster wide perspective. The API returns basic index metrics (shard numbers, store size, memory usage) and information about the current nodes that form the cluster (number, roles, os, jvm versions, memory usage, cpu and installed plugins).","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/stats","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["stats"],"absoluteUri":"{protocol}://{domain}:{port}/_cluster/stats"},{"relativeUri":"/state","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"description":"The cluster state API allows to get a comprehensive state information of the whole cluster.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"resources":[{"relativeUri":"/{metrics}/{indices}","type":"base","uriParameters":{"metrics":{"name":"metrics","displayName":"metrics","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"indices":{"name":"indices","displayName":"indices","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"description":"As the cluster state can grow (depending on the number of shards and indices, your mapping, templates), it is possible to filter the cluster state response specifying the parts in the URL.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/{metrics}/{indices}","description":"metrics can be a comma-separated list of\nversion - Shows the cluster state version. \nmaster_node - Shows the elected master_node part of the response \nnodes -  Shows the nodes part of the response \nrouting_table  - Shows the routing_table part of the response. If you supply a comma separated list of \nindices, the returned output will only contain the indices listed. \nmetadata - Shows the metadata part of the response. If you supply a comma separated list of indices, the \nreturned output will only contain the indices listed. blocks   Shows the blocks part of the response\n","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["{metrics}","{indices}"],"absoluteUri":"{protocol}://{domain}:{port}/_cluster/state/{metrics}/{indices}"}],"displayName":"/state","description":"","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["state"],"absoluteUri":"{protocol}://{domain}:{port}/_cluster/state"},{"relativeUri":"/settings","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"description":"Cluster wide settings can be returned using","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"body":{"application/json":{"name":"application/json","schema":"clusterSettings","example":"Can not resolve examples/clusterSettings-example.json","schemaContent":"Can not resolve schemas/clusterSettings-schema.json"}},"protocols":["{PROTOCOL}"],"description":"Allows to update cluster wide specific settings. Settings updated can either be persistent (applied cross restarts) or transient (will not survive a full cluster restart).","method":"put","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/settings","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["settings"],"absoluteUri":"{protocol}://{domain}:{port}/_cluster/settings"},{"relativeUri":"/reroute","type":"base","methods":[{"body":{"application/json":{"name":"application/json","schema":"rerouteSpec","example":"Can not resolve examples/rerouteSpec-example.json","schemaContent":"Can not resolve schemas/rerouteSpec-schema.json"}},"protocols":["{PROTOCOL}"],"description":"The reroute command allows to explicitly execute a cluster reroute allocation command including specific commands. For example, a shard can be moved from one node to another explicitly, an allocation can be canceled, or an unassigned shard can be explicitly allocated on a specific node.\n\nAn important aspect to remember is the fact that once when an allocation occurs, the cluster will aim at re-balancing its state back to an even state. For example, if the allocation includes moving a shard from node1 to \nnode2, in an \neven state, then another shard will be moved from \nnode2 to \nnode1 to even things out.\n\nThe cluster can be set to disable allocations, which means that only the explicitly allocations will be performed. Obviously, only once all commands has been applied, the cluster will aim to be re-balance its state.\n\nAnother option is to run the commands in dry_run (as a URI flag, or in the request body). This will \ncause the commands to apply to the current cluster state, and return the resulting cluster after the commands (and re-balancing) has been applied.\n\nIf the explain parameter is specified, a detailed explanation of why the commands could or could \nnot be executed is returned.\n\nThe commands supported are:\nmove \n Move a started shard from one node to another node. Accepts index and \nshard for index \nname and shard number, from_node for the node to move the shard \nfrom, and \nto_node for \nthe node to move the shard to. \ncancel \n Cancel allocation of a shard (or recovery). Accepts index and \nshard for index name and \nshard number, and node for the node to cancel the shard allocation on. It also accepts \nallow_primary flag to explicitly specify that it is allowed to cancel allocation for a primary \nshard. \nallocate \n Allocate an unassigned shard to a node. Accepts the index and \nshard for index name and \nshard number, and node to allocate the shard to. It also accepts \nallow_primary flag to \nexplicitly specify that it is allowed to explicitly allocate a primary shard (might result in data loss).\n","method":"post","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/reroute","description":"","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["reroute"],"absoluteUri":"{protocol}://{domain}:{port}/_cluster/reroute"},{"relativeUri":"/health/{indicesList}","type":"base","uriParameters":{"indicesList":{"name":"indicesList","displayName":"indicesList","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"queryParameters":{"pretty":{"name":"pretty","displayName":"pretty","type":"boolean","required":false,"repeat":false,"__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"wait_for_status":{"name":"wait_for_status","displayName":"wait_for_status","type":"string","required":false,"repeat":false,"description":"One of green, yellow or  red. Will wait (until the timeout provided) until the status of the cluster changes to the one provided or better, i.e. green >  yellow >  red. By default, will  not wait for any status.","enum":["red","green","yellow"],"__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"timeout":{"name":"timeout","displayName":"timeout","type":"string","required":false,"repeat":false,"__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"level":{"name":"level","displayName":"level","type":"string","required":false,"default":"cluster","repeat":false,"description":"Can be one of cluster, \nindices or \nshards. Controls the details level of the health \ninformation returned. Defaults to cluster.\n","enum":["shards","cluster","indices"],"__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"wait_for_relocating_shards":{"name":"wait_for_relocating_shards","displayName":"wait_for_relocating_shards","type":"string","required":false,"repeat":false,"description":"A number controlling to how many relocating shards to wait for. Usually will be 0 to indicate \nto wait till all relocations have happened. Defaults to not wait.\n","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"wait_for_nodes":{"name":"wait_for_nodes","displayName":"wait_for_nodes","type":"string","required":false,"repeat":false,"description":"The request waits until the specified number N of nodes is available. It also accepts  >=N,  <=N,  >N and  <N. Alternatively, it is possible to use  ge(N),  le(N),  gt(N) and  lt(N) notation.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"description":"The cluster health API allows to get a very simple status on the health of the cluster.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/health/{indicesList}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["health","{indicesList}"],"absoluteUri":"{protocol}://{domain}:{port}/_cluster/health/{indicesList}"},{"relativeUri":"/nodes/{nodeList}/_shutdown","uriParameters":{"nodeList":{"name":"nodeList","displayName":"nodeList","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"protocols":["{PROTOCOL}"],"queryParameters":{"delay":{"name":"delay","displayName":"delay","type":"string","required":false,"default":"1s","example":"10s","repeat":false,"description":"By default, the shutdown will be executed after a 1 second delay (1s). The delay can be customized by setting the delay parameter in a time value format.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"description":"The nodes shutdown API allows to shutdown one or more (or all) nodes in the cluster.","method":"post","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/nodes/{nodeList}/_shutdown","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["nodes","{nodeList}","_shutdown"],"absoluteUri":"{protocol}://{domain}:{port}/_cluster/nodes/{nodeList}/_shutdown"}],"displayName":"/_cluster","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_cluster"],"absoluteUri":"{protocol}://{domain}:{port}/_cluster"},{"relativeUri":"/_cat","resources":[{"relativeUri":"/nodes","type":"catResource","methods":[{"protocols":["{PROTOCOL}"],"description":"The nodes command shows the cluster topology.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/nodes","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["nodes"],"absoluteUri":"{protocol}://{domain}:{port}/_cat/nodes"},{"relativeUri":"/health","type":"catResource","methods":[{"protocols":["{PROTOCOL}"],"queryParameters":{"ts":{"name":"ts","displayName":"ts","type":"string","required":false,"repeat":false,"description":"ts allows to disable the timestamping","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"description":"health is a terse, one-line representation of the same information from /_cluster/health. It has one option ts to disable the timestamping.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/health","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["health"],"absoluteUri":"{protocol}://{domain}:{port}/_cat/health"},{"relativeUri":"/indices","type":"catResource","methods":[{"protocols":["{PROTOCOL}"],"description":"The indices command provides a cross-section of each index. This information spans nodes.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/indices","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["indices"],"absoluteUri":"{protocol}://{domain}:{port}/_cat/indices"},{"relativeUri":"/fielddata","type":"catResource","methods":[{"protocols":["{PROTOCOL}"],"queryParameters":{"fields":{"name":"fields","displayName":"fields","type":"string","required":false,"repeat":false,"description":"comma separated list of fields","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"description":"fielddata shows information about currently loaded fielddata on a per-node basis.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/fielddata","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["fielddata"],"absoluteUri":"{protocol}://{domain}:{port}/_cat/fielddata"},{"relativeUri":"/pending_tasks","type":"catResource","methods":[{"protocols":["{PROTOCOL}"],"description":"pending_tasks provides the same information as the /_cluster/pending_tasks API in a convenient tabular format.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/pending_tasks","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["pending_tasks"],"absoluteUri":"{protocol}://{domain}:{port}/_cat/pending_tasks"},{"relativeUri":"/allocation","type":"catResource","methods":[{"protocols":["{PROTOCOL}"],"description":"allocation provides a snapshot of how shards have located around the cluster and the state of disk usage.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/allocation","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["allocation"],"absoluteUri":"{protocol}://{domain}:{port}/_cat/allocation"},{"relativeUri":"/thread_pool","type":"catResource","methods":[{"protocols":["{PROTOCOL}"],"description":"The thread_pool command shows cluster wide thread pool statistics per node. By default the active, queue and rejected statistics are returned for the bulk, index and search thread pools.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/thread_pool","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["thread_pool"],"absoluteUri":"{protocol}://{domain}:{port}/_cat/thread_pool"},{"relativeUri":"/shards","type":"catResource","methods":[{"protocols":["{PROTOCOL}"],"description":"The shards command is the detailed view of what nodes contain which shards. It will tell you if it's \na primary or replica, the number of docs, the bytes it takes on disk, and the node where it's located.\n","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/shards","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["shards"],"absoluteUri":"{protocol}://{domain}:{port}/_cat/shards"},{"relativeUri":"/aliases","type":"catResource","methods":[{"protocols":["{PROTOCOL}"],"queryParameters":{"v":{"name":"v","displayName":"v","type":"string","required":false,"repeat":false,"description":"Each of the commands accepts a query string parameter v to turn on verbose output.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"help":{"name":"help","displayName":"help","type":"string","required":false,"repeat":false,"description":"Each of the commands accepts a query string parameter help which will output its available columns.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"h":{"name":"h","displayName":"h","type":"string","required":false,"example":"h=ip,port,heapPercent,name","repeat":false,"description":"Each of the commands accepts a query string parameter h which forces only those columns to appear.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}},"bytes":{"name":"bytes","displayName":"bytes","type":"string","required":false,"example":"bytes=b","repeat":false,"description":"We'll use a byte-level resolution.","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"description":"aliases shows information about currently configured aliases to indices including filter and \nrouting infos.\n","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/aliases","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["aliases"],"absoluteUri":"{protocol}://{domain}:{port}/_cat/aliases"},{"relativeUri":"/recovery","type":"catResource","methods":[{"protocols":["{PROTOCOL}"],"description":"The recovery command is a view of index shard recoveries, both on-going and previously completed. It is a more compact view of the JSON recovery API.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/recovery","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["recovery"],"absoluteUri":"{protocol}://{domain}:{port}/_cat/recovery"},{"relativeUri":"/plugins","type":"catResource","methods":[{"protocols":["{PROTOCOL}"],"description":"The plugins command provides a view per node of running plugins. This information spans nodes.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/plugins","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["plugins"],"absoluteUri":"{protocol}://{domain}:{port}/_cat/plugins"},{"relativeUri":"/master","type":"catResource","methods":[{"protocols":["{PROTOCOL}"],"description":"master doesn't have any extra options. It simply displays the master's node ID, bound IP address, and node name.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/master","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["master"],"absoluteUri":"{protocol}://{domain}:{port}/_cat/master"},{"relativeUri":"/count/{indicesSelection}","type":"catResource","uriParameters":{"indicesSelection":{"name":"indicesSelection","displayName":"indicesSelection","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"protocols":["{PROTOCOL}"],"description":"count provides quick access to the document count of the entire cluster, or individual indices.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/count/{indicesSelection}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["count","{indicesSelection}"],"absoluteUri":"{protocol}://{domain}:{port}/_cat/count/{indicesSelection}"}],"displayName":"/_cat","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_cat"],"absoluteUri":"{protocol}://{domain}:{port}/_cat"},{"relativeUri":"/_bench","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"benchResponse","example":"Can not resolve examples/benchResponse-example.json","schemaContent":"Can not resolve schemas/benchResponse-schema.json"}}}},"body":{"application/json":{"name":"application/json","schema":"benchSample","example":"Can not resolve examples/benchSample-example.json","schemaContent":"Can not resolve schemas/benchSample-schema.json"}},"protocols":["{PROTOCOL}"],"description":"The benchmark API provides a standard mechanism for submitting queries and measuring their performance relative to one another.","method":"put","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"benchResponse","example":"Can not resolve examples/benchResponse-example.json","schemaContent":"Can not resolve schemas/benchResponse-schema.json"}}}},"protocols":["{PROTOCOL}"],"description":"View all active benchmarks.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"resources":[{"relativeUri":"/abort/{benchName}","uriParameters":{"benchName":{"name":"benchName","displayName":"benchName","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"benchAbortResponse","example":"Can not resolve examples/benchAbortResponse-example.json","schemaContent":"Can not resolve schemas/benchAbortResponse-schema.json"}}}},"protocols":["{PROTOCOL}"],"description":"Abort a benchmark.","method":"post","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/abort/{benchName}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["abort","{benchName}"],"absoluteUri":"{protocol}://{domain}:{port}/_bench/abort/{benchName}"}],"displayName":"/_bench","description":"","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_bench"],"absoluteUri":"{protocol}://{domain}:{port}/_bench"},{"relativeUri":"/_suggest","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"suggestResponse","example":"Can not resolve examples/suggestResponse-example.json","schemaContent":"Can not resolve schemas/suggestResponse-schema.json"}}}},"body":{"application/json":{"name":"application/json","schema":"suggestExample","example":"Can not resolve examples/suggestExample-example.json","schemaContent":"Can not resolve schemas/suggestExample-schema.json"}},"protocols":["{PROTOCOL}"],"description":"The suggest feature suggests similar looking terms based on a provided text by using a suggester. Parts of the suggest feature are still under development","method":"post","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_suggest","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_suggest"],"absoluteUri":"{protocol}://{domain}:{port}/_suggest"},{"relativeUri":"/_mpercolate","type":"mpercolateType","displayName":"/_mpercolate","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_mpercolate"],"absoluteUri":"{protocol}://{domain}:{port}/_mpercolate"},{"relativeUri":"/_search","type":"searchType","resources":[{"relativeUri":"/template","type":"searchType","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"body":{"application/json":{"name":"application/json","schema":"searchTemplate","example":"Can not resolve examples/searchTemplate-example.json","schemaContent":"Can not resolve schemas/searchTemplate-schema.json"}},"protocols":["{PROTOCOL}"],"description":"The /_search/template endpoint allows to use the mustache language to pre render search \nrequests, before they are executed and fill existing templates with template parameters.\n","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/template","description":"","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["template"],"absoluteUri":"{protocol}://{domain}:{port}/_search/template"}],"displayName":"/_search","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_search"],"absoluteUri":"{protocol}://{domain}:{port}/_search"},{"relativeUri":"/_mapping","type":"mappingType","methods":[{"protocols":["{PROTOCOL}"],"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"resources":[{"relativeUri":"/{_index}","type":"mappingType","uriParameters":{"_index":{"name":"_index","displayName":"_index","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"protocols":["{PROTOCOL}"],"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/{_index}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["{_index}"],"absoluteUri":"{protocol}://{domain}:{port}/_mapping/{_index}"}],"displayName":"/_mapping","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_mapping"],"absoluteUri":"{protocol}://{domain}:{port}/_mapping"},{"relativeUri":"/_aliases","type":"base","methods":[{"responses":{"201":{"code":"201"}},"body":{"application/json":{"name":"application/json","schema":"aliasOps","example":"Can not resolve examples/aliasOps-example.json","schemaContent":"Can not resolve schemas/aliasOps-schema.json"}},"protocols":["{PROTOCOL}"],"description":"APIs in elasticsearch accept an index name when working against a specific index, and several indices when applicable. The index aliases API allow to alias an index with a name, with all APIs automatically converting the alias name to the actual index name. An alias can also be mapped to more than one index, and when specifying it, the alias will automatically expand to the aliases indices. An alias can also be associated with a filter that will automatically be applied when searching, and routing values.","method":"post","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_aliases","description":"","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_aliases"],"absoluteUri":"{protocol}://{domain}:{port}/_aliases"},{"relativeUri":"/_settings","type":"indexSettingsType","displayName":"/_settings","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_settings"],"absoluteUri":"{protocol}://{domain}:{port}/_settings"},{"relativeUri":"/_analyze","type":"analizerType","displayName":"/_analyze","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_analyze"],"absoluteUri":"{protocol}://{domain}:{port}/_analyze"},{"relativeUri":"/_template/{templateId}","type":"base","uriParameters":{"templateId":{"name":"templateId","displayName":"templateId","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"responses":{"200":{"code":"200"}},"body":{"application/json":{"name":"application/json","schema":"indexTemplate","example":"Can not resolve examples/indexTemplate-example.json","schemaContent":"Can not resolve schemas/indexTemplate-schema.json"}},"protocols":["{PROTOCOL}"],"description":"Create index template","method":"put","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"protocols":["{PROTOCOL}"],"description":"Index templates are identified by a name (in the above case template_1) and can be deleted as \nwell\n","method":"delete","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}},{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json","schema":"indexTemplate","example":"Can not resolve examples/indexTemplate-example.json","schemaContent":"Can not resolve schemas/indexTemplate-schema.json"}}}},"protocols":["{PROTOCOL}"],"description":"Return index template","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_template/{templateId}","description":"Index templates allow to define templates that will automatically be applied to new indices created. The templates include both settings and mappings, and a simple pattern template that controls if the template will be applied to the index created","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_template","{templateId}"],"absoluteUri":"{protocol}://{domain}:{port}/_template/{templateId}"},{"relativeUri":"/_warmer/{warmer_name}","type":"warmerType","uriParameters":{"warmer_name":{"name":"warmer_name","displayName":"warmer_name","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"protocols":["{PROTOCOL}"],"method":"put","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_warmer/{warmer_name}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_warmer","{warmer_name}"],"absoluteUri":"{protocol}://{domain}:{port}/_warmer/{warmer_name}"},{"relativeUri":"/_warmers/{warmer_name}","type":"warmerType","uriParameters":{"warmer_name":{"name":"warmer_name","displayName":"warmer_name","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"protocols":["{PROTOCOL}"],"method":"put","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_warmers/{warmer_name}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_warmers","{warmer_name}"],"absoluteUri":"{protocol}://{domain}:{port}/_warmers/{warmer_name}"},{"relativeUri":"/_status","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"description":"The indices status API allows to get a comprehensive status information of one or more indices.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_status","description":"","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_status"],"absoluteUri":"{protocol}://{domain}:{port}/_status"},{"relativeUri":"/_stats","type":"base","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"description":"Indices level stats provide statistics on different operations happening on an index. The API provides statistics on the index level scope (though most stats can also be retrieved using node level scope).\n\nThe following returns high level aggregation and index level stats for all indices\n","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"resources":[{"relativeUri":"/{statSpec}","type":"base","uriParameters":{"statSpec":{"name":"statSpec","displayName":"statSpec","type":"string","required":true,"repeat":false,"__METADATA__":{"calculated":true,"primitiveValuesMeta":{"displayName":{"calculated":true},"type":{"insertedAsDefault":true},"required":{"insertedAsDefault":true},"repeat":{"insertedAsDefault":true}}}}},"methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"description":"Indices level stats provide statistics on different operations happening on an index.","method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/{statSpec}","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["{statSpec}"],"absoluteUri":"{protocol}://{domain}:{port}/_stats/{statSpec}"}],"displayName":"/_stats","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_stats"],"absoluteUri":"{protocol}://{domain}:{port}/_stats"},{"relativeUri":"/_segments","type":"segmentsType","displayName":"/_segments","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_segments"],"absoluteUri":"{protocol}://{domain}:{port}/_segments"},{"relativeUri":"/_recovery","type":"recoveryType","displayName":"/_recovery","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_recovery"],"absoluteUri":"{protocol}://{domain}:{port}/_recovery"},{"relativeUri":"/_cache/clear","type":"cacheClearType","displayName":"/_cache/clear","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_cache","clear"],"absoluteUri":"{protocol}://{domain}:{port}/_cache/clear"},{"relativeUri":"/_flush","type":"flushType","displayName":"/_flush","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_flush"],"absoluteUri":"{protocol}://{domain}:{port}/_flush"},{"relativeUri":"/_refresh","type":"refreshType","displayName":"/_refresh","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_refresh"],"absoluteUri":"{protocol}://{domain}:{port}/_refresh"},{"relativeUri":"/_optimize","type":"optimizeType","displayName":"/_optimize","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_optimize"],"absoluteUri":"{protocol}://{domain}:{port}/_optimize"},{"relativeUri":"/_mtermvectors","type":"multiTermVectors","methods":[{"responses":{"200":{"code":"200","body":{"application/json":{"name":"application/json"}}}},"protocols":["{PROTOCOL}"],"method":"get","__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}],"displayName":"/_mtermvectors","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_mtermvectors"],"absoluteUri":"{protocol}://{domain}:{port}/_mtermvectors"},{"relativeUri":"/_msearch","type":"msearchType","displayName":"/_msearch","__METADATA__":{"primitiveValuesMeta":{"displayName":{"calculated":true}}},"relativeUriPathSegments":["_msearch"],"absoluteUri":"{protocol}://{domain}:{port}/_msearch"}],"documentation":[{"title":"Headline","content":"Can not resolve docs/headline.md"}],"__METADATA__":{"primitiveValuesMeta":{"protocols":{"calculated":true}}}}